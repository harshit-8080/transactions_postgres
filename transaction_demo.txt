exports.transactions_demo = async(req,res)=>{
	
	const t = await sequelize.transaction();

	try{
		const user = await db.user.create(userObject,{transaction:t});

		const data = await db.user.findAll({
			where:{
				id:100;
			}
		},{
			transaction:t
		});

		await t.commit();
		
	}
	catch(error){
		await t.rollback();
	}	

}

There are 3 read phenomena :-	1. Dirty Reads, 2. Reapeatable Reads, 3. Phantom Reads

Isolation levels in transactions
	
	Isolation leve only applies to other concurrent transactions.
	Transaction can always see the changes it makes - Regardless of isolation levels.


	const { Transaction } = require('sequelize');



	// The following are valid isolation levels:
	
	
	1.	Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // "READ UNCOMMITTED"  	 -> 	
			1.	This isolation level allows dirty reads.
			2.	One transaction may see uncommitted changes made by some other transaction.
	
	
	2.	Transaction.ISOLATION_LEVELS.READ_COMMITTED // "READ COMMITTED"      	 -> 	
			1.	better level of isolation (by Default in postgres) 
			2.	When one ongoing transaction can read the changes of other committed transaction.

	
	3.	Transaction.ISOLATION_LEVELS.REPEATABLE_READ  // "REPEATABLE READ"   	 -> 	
			1.	reads data from the time Stap  Transactions begins.
			2.	When one ongoing transaction is not allowed to read the changes of other committed transaction.
			3.	command in PG	->	begin transaction isolation level repeatable read;
			4.	Important for consistency
	
	
	4.	Transaction.ISOLATION_LEVELS.SERIALIZABLE // "SERIALIZABLE"        		 ->   
			1.	highest level of isolation where transactions are completely isolated from one another.

 
 
 NOTE :- Postgres is special as it saves us form phantam reads even with ISOLATION_LEVELS.REPEATABLE_READ (dont need SERIALIZABLE).



Points to remember :-
	1. sequelize dont do use transaction bydefault.

	2.	BUt we should use transaction for productions

	3.	Two Types of transactions in sequelize
			1.	unmanaged transaction  --> Above example is unmanaged  transaction as here we are doing manually

			2.	managed transaction --> Managed transactions handle committing or rolling back the transaction automatically. 
										You start a managed transaction by passing a callback to sequelize.transaction.

	4.		

